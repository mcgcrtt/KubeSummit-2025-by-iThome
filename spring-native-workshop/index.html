
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Spring Native Workshop - Image Analysis Application</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="spring-native-workshop"
                  title="Spring Native Workshop - Image Analysis Application"
                  environment="web"
                  feedback-link="https://github.com/mcgcrtt/KubeSummit-2025-by-iThome">
    
      <google-codelab-step label="概述 &amp; 架構說明" duration="2">
        <p>在本實驗中，您將實作如何：</p>
<ul>
<li>建置 JIT 和 Native 的 Spring Boot 應用程式</li>
<li>比較兩種版本在映像檔大小、啟動時間和系統資源使用上的差異</li>
<li>將應用程式部署到 Google Cloud Run</li>
<li>整合 Google Cloud Vision API、Cloud Storage 和 Firestore</li>
<li>使用 Eventarc 建立事件驅動架構</li>
</ul>
<h2 is-upgraded>架構圖</h2>
<p class="image-container"><img alt="Architecture Diagram" src="img/69c9d199a09ec2e1.png"></p>
<p>應用程式流程：</p>
<ol type="1">
<li>使用者上傳圖片到 Cloud Storage</li>
<li>Cloud Storage 觸發 Eventarc 事件</li>
<li>Eventarc 呼叫 Cloud Run 服務</li>
<li>Cloud Run 服務使用 Vision API 分析圖片</li>
<li>分析結果儲存到 Firestore</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="前置準備" duration="8">
        <h2 is-upgraded>1. Google Cloud Project 設定</h2>
<p>在開始之前，您需要：</p>
<ol type="1">
<li>擁有一個 Google Cloud 專案</li>
<li>啟用計費功能</li>
<li>具備專案的 Owner 或 Editor 權限</li>
</ol>
<h2 is-upgraded>2. 建立 Compute Engine VM</h2>
<p>建立一台 VM 來執行本 Workshop 的建置工作：</p>
<p><strong>建議規格</strong>：</p>
<ul>
<li><strong>地區</strong>：asia-east1 (台灣)</li>
<li><strong>區域</strong>：any</li>
<li><strong>作業系統</strong>：Ubuntu 24.04 LTS x86/64</li>
<li><strong>機器類型</strong>：e2-standard-4 (4 vCPUs, 16 GB Memory)</li>
<li><strong>開機磁碟大小</strong>：100 GB (Balanced persistent disk)</li>
</ul>
<p><strong>透過 Console 建立 VM</strong>：</p>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/compute/instances" target="_blank">Compute Engine &gt; VM 執行個體</a></li>
<li>點擊「建立執行個體」</li>
<li>設定以下參數： <ul>
<li><strong>名稱</strong>：<code>spring-native-workshop-vm</code>（或您喜歡的名稱）</li>
<li><strong>地區</strong>：<code>asia-east1 (台灣)</code></li>
<li><strong>區域</strong>：<code>any</code></li>
<li><strong>機器類型</strong>：<code>e2-standard-4</code> (4 vCPUs, 16 GB Memory)</li>
<li><strong>開機磁碟</strong>： <ul>
<li>作業系統：Ubuntu</li>
<li>版本：Ubuntu 24.04 LTS x86/64</li>
<li>大小：100 GB</li>
</ul>
</li>
</ul>
</li>
<li>其他皆使用預設值</li>
<li>點擊「建立」</li>
</ol>
<p class="image-container"><img alt="VM Specification" src="img/9cc0be3de07b3770.png"><img alt="VM OS" src="img/a0adcf046b94adf8.png"></p>
<p><strong>連線到 VM</strong>：</p>
<ul>
<li>點擊 <code>ssh</code>，接著就可以看到連線畫面操作 VM，如下圖：</li>
</ul>
<p class="image-container"><img alt="SSH to VM" src="img/d3153c8bb752e92f.png"></p>
<p><strong>注意</strong>：Native Image 編譯需要較多記憶體，建議至少使用 16 GB 記憶體的機器類型。</p>
<h2 is-upgraded>3. 環境設定</h2>
<p>連線到 VM 後，安裝以下工具（可使用 <code>Lab/env/setup.sh</code> 腳本自動安裝）：</p>
<ul>
<li>Docker</li>
<li>build-essential (gcc, g++, make)</li>
<li>SDKMAN</li>
<li>GraalVM Java 17</li>
<li>Maven</li>
</ul>
<p><strong>快速安裝</strong>：</p>
<pre><code language="language-bash" class="language-bash"># Clone workshop repository (如果您的專案在 GitHub)
git clone https://github.com/mcgcrtt/KubeSummit-2025-by-iThome.git
cd spring-native-workshop/Lab

# 執行安裝腳本
chmod +x ./env/setup.sh
./env/setup.sh
</code></pre>
<p>或手動安裝每個工具（請參考 <code>Lab/env/setup.sh</code> 腳本內容）。</p>
<h2 is-upgraded>4. 驗證 Java 環境</h2>
<p>確認使用的是 GraalVM 而非 OpenJDK：</p>
<pre><code language="language-bash" class="language-bash"># 載入 SDKMAN 環境
. $HOME/.sdkman/bin/sdkman-init.sh

# 檢查當前 Java 版本
sdk current java

# 驗證 JAVA_HOME
echo $JAVA_HOME
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Google Cloud 認證設定" duration="2">
        <h2 is-upgraded>1. 登入 Google Cloud</h2>
<pre><code language="language-bash" class="language-bash"># 登入 Google Cloud
gcloud auth login

# 設定應用程式預設憑證 (ADC)
gcloud auth application-default login
</code></pre>
<h2 is-upgraded>2. 設定專案環境變數</h2>
<pre><code language="language-bash" class="language-bash"># 設定專案 ID
export PROJECT_ID=$(gcloud config get-value project)
export PROJECT_NUMBER=$(gcloud projects describe $PROJECT_ID --format=&#39;value(projectNumber)&#39;)

# 設定 gcloud 預設值
gcloud config set project ${PROJECT_ID}
gcloud config set run/platform managed
gcloud config set eventarc/location asia-east1
</code></pre>
<h2 is-upgraded>3. 啟用所需的 Google Cloud API</h2>
<pre><code language="language-bash" class="language-bash"># 啟用 Vision API (圖片分析)、Cloud Functions API、Cloud Build API、Cloud Run API、Artifact Registry API、Eventarc API、Pub/Sub API (Eventarc 需要)
gcloud services enable \
    vision.googleapis.com \
    cloudfunctions.googleapis.com \
    cloudbuild.googleapis.com \
    run.googleapis.com \
    artifactregistry.googleapis.com \
    eventarc.googleapis.com \
    pubsub.googleapis.com
</code></pre>
<h2 is-upgraded>4. 建立 Artifact Registry Repository</h2>
<ul>
<li>使用 <code>gcloud CLI</code> 或者從 <code>GCP Console</code> 建立：</li>
</ul>
<pre><code language="language-bash" class="language-bash"># 建立 JIT 版本的 Docker Repository
gcloud artifacts repositories create jit-image-docker-repo \
  --repository-format=docker \
  --location=asia-east1 \
  --description=&#34;JIT version Docker images&#34;
</code></pre>
<p class="image-container"><img alt="JIT Artifact Registry" src="img/2f0578e642a899f3.png"></p>
<pre><code language="language-bash" class="language-bash"># 建立 Native 版本的 Docker Repository
gcloud artifacts repositories create native-image-docker-repo \
  --repository-format=docker \
  --location=asia-east1 \
  --description=&#34;Native version Docker images&#34;
</code></pre>
<p class="image-container"><img alt="Native Artifact Registry" src="img/dd1777cf1ef14d5c.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="建立 Google Cloud Storage" duration="2">
        <h2 is-upgraded>1. 建立 Storage Bucket</h2>
<ul>
<li>使用 <code>gcloud CLI</code> 或者從 <code>GCP Console</code> 建立，用於儲存上傳圖片的 GCS Bucket：</li>
</ul>
<pre><code language="language-bash" class="language-bash"># 設定 Bucket 名稱
export BUCKET_PICTURES=uploaded-pictures-${PROJECT_ID}

# 建立 Bucket (位於歐洲區域)
gsutil mb -l asia-east1 gs://${BUCKET_PICTURES}

# 啟用統一的 Bucket 層級存取控制
gsutil uniformbucketlevelaccess set on gs://${BUCKET_PICTURES}

# 設定公開讀取權限
gsutil iam ch allUsers:objectViewer gs://${BUCKET_PICTURES}
</code></pre>
<h2 is-upgraded>2. 設定 Storage 服務帳戶權限</h2>
<p>為了讓 Cloud Storage 能夠發送 Pub/Sub 事件，需要授予服務帳戶 <code>pubsub.publisher</code> 權限：</p>
<pre><code language="language-bash" class="language-bash"># 取得 Cloud Storage 服務帳戶
SERVICE_ACCOUNT=&#34;$(gsutil kms serviceaccount -p ${PROJECT_ID})&#34;

# 授予 pubsub.publisher 角色
gcloud projects add-iam-policy-binding ${PROJECT_ID} \
    --member=&#34;serviceAccount:${SERVICE_ACCOUNT}&#34; \
    --role=&#39;roles/pubsub.publisher&#39;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="建立 Firestore 資料庫" duration="2">
        <h2 is-upgraded>1. 透過 Console 建立 Firestore</h2>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/firestore" target="_blank">Google Cloud Console - Firestore</a></li>
<li>點擊「建立資料庫」</li>
<li>選擇 <strong>Standard Edition</strong></li>
<li>選擇 <strong>Firestore Native</strong></li>
<li>選擇區域（建議選擇靠近 GCS Bucket 所在區域，前面是選擇亞洲，因此這邊選擇：<code>asia-east1</code>）</li>
<li>點擊「建立」</li>
</ol>
<p class="image-container"><img alt="Firestore Console" src="img/d3d130ff600c6d2a.png"><img alt="Firestore Region" src="img/d52dcb7aaae4cf85.png"></p>
<h2 is-upgraded>2. 建立 Collection</h2>
<p>在 Firestore Console 中：</p>
<ol type="1">
<li>點擊「Start Collection」</li>
<li>Collection ID 輸入：<code>pictures</code></li>
<li>新增一個測試文件（建立完成會由應用程式自動寫入）</li>
<li>將測試文件刪除</li>
</ol>
<p class="image-container"><img alt="Firestore Collection" src="img/13871f10ed54ecd1.png"><img alt="Delete Test File" src="img/eda8bafe1e90f408.png"></p>
<h2 is-upgraded>3. 建立複合索引</h2>
<pre><code language="language-bash" class="language-bash"># 建立用於查詢的複合索引
gcloud firestore indexes composite create \
  --collection-group=pictures \
  --field-config field-path=thumbnail,order=descending \
  --field-config field-path=created,order=descending
</code></pre>
<p><strong>注意</strong>：索引建立可能需要數分鐘時間。</p>


      </google-codelab-step>
    
      <google-codelab-step label="本地建置與測試 (JIT 版本)" duration="10">
        <h2 is-upgraded>1. 建置 &amp; 本地執行 JIT 應用程式</h2>
<pre><code language="language-bash" class="language-bash"># 使用 Maven Wrapper 建置專案
./mvnw package -Pjit
</code></pre>
<p>建置完成後，會在 <code>target/</code> 目錄下產生 JAR 檔案：<code>image-analysis-0.0.1.jar</code></p>
<p class="image-container"><img alt="JIT Local Build" src="img/222c4fa6257b85e5.png"></p>
<pre><code language="language-bash" class="language-bash"># 啟動應用程式
java -jar ./target/image-analysis-0.0.1.jar
</code></pre>
<p class="image-container"><img alt="JIT Local Run" src="img/1db116d248634248.png"></p>
<h2 is-upgraded>2. 建置 &amp; Docker 執行 JIT Docker 映像檔</h2>
<pre><code language="language-bash" class="language-bash"># 使用 jit profile 建置 Docker 映像檔
./mvnw spring-boot:build-image -Pjit
</code></pre>
<p>這個指令會：</p>
<ul>
<li>使用 Cloud Native Buildpacks</li>
<li>建立最佳化的分層映像檔</li>
<li>映像檔名稱：<code>image-analysis-maven-jit</code></li>
</ul>
<p class="image-container"><img alt="Docker JIT Build" src="img/80d32e3c470d5cc7.png"></p>
<pre><code language="language-bash" class="language-bash"># 啟動應用程式
docker run --rm image-analysis-maven-jit:latest 
</code></pre>
<p class="image-container"><img alt="JIT Docker Run" src="img/4416baf52df22a47.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="本地建置與測試 (Native 版本)" duration="25">
        <h2 is-upgraded>1. 建置 &amp; 本地執行 Native 執行檔</h2>
<pre><code language="language-bash" class="language-bash"># 使用 native profile 建置原生執行檔
./mvnw native:compile -Pnative
</code></pre>
<p><strong>重要</strong>：Native 編譯需要較長時間，請耐心等待。</p>
<p>建置完成後，會在 <code>target/</code> 目錄下產生原生執行檔：<code>image-analysis</code></p>
<p class="image-container"><img alt="Native Local Build" src="img/6a3b5c26f07f7011.png"></p>
<pre><code language="language-bash" class="language-bash"># 執行原生執行檔
./target/image-analysis
</code></pre>
<p class="image-container"><img alt="Native Local Run" src="img/2f0817829661a97d.png"></p>
<h2 is-upgraded>2. 建置 &amp; Docker 執行 Native Docker 映像檔</h2>
<pre><code language="language-bash" class="language-bash"># 使用 native profile 建置 Docker 映像檔
./mvnw spring-boot:build-image -Pnative
</code></pre>
<p>這個指令會：</p>
<ul>
<li>使用 GraalVM Native Image</li>
<li>建立極小化的容器映像檔</li>
<li>映像檔名稱：<code>image-analysis-maven-native</code></li>
</ul>
<p class="image-container"><img alt="Docker Native Build" src="img/346380f124211b00.png"></p>
<pre><code language="language-bash" class="language-bash"># 啟動應用程式
docker run --rm image-analysis-maven-native:latest 
</code></pre>
<p class="image-container"><img alt="Native Docker Run" src="img/c43f04d11f1c1a04.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="比較 JIT vs Native" duration="4">
        <h2 is-upgraded>1. 比較映像檔大小</h2>
<pre><code language="language-bash" class="language-bash"># 查看兩個版本的映像檔大小
docker images | grep image-analysis
</code></pre>
<p class="image-container"><img alt="Docker Images Comparison" src="img/8edfc15f4b2af8da.png"></p>
<h2 is-upgraded>2. 比較啟動時間</h2>
<p><strong>測試 JIT 版本</strong>：</p>
<pre><code language="language-bash" class="language-bash">docker run --rm image-analysis-maven-jit
</code></pre>
<p>觀察啟動日誌中的時間。</p>
<p class="image-container"><img alt="Docker JIT Run" src="img/4416baf52df22a47.png"></p>
<p><strong>測試 Native 版本</strong>：</p>
<pre><code language="language-bash" class="language-bash">docker run --rm image-analysis-maven-native
</code></pre>
<p>觀察啟動日誌中的時間。</p>
<p class="image-container"><img alt="Docker Native Run" src="img/c43f04d11f1c1a04.png"></p>
<h2 is-upgraded>3. 效能比較總結</h2>
<table>
<tr><td colspan="1" rowspan="1"><p>指標</p>
</td><td colspan="1" rowspan="1"><p>JIT 版本</p>
</td><td colspan="1" rowspan="1"><p>Native 版本</p>
</td><td colspan="1" rowspan="1"><p>改善幅度</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>映像檔大小</p>
</td><td colspan="1" rowspan="1"><p>~400MB</p>
</td><td colspan="1" rowspan="1"><p>~200MB</p>
</td><td colspan="1" rowspan="1"><p><strong>減少 50%</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>啟動時間</p>
</td><td colspan="1" rowspan="1"><p>~5-10 秒</p>
</td><td colspan="1" rowspan="1"><p>~0.05-1 秒</p>
</td><td colspan="1" rowspan="1"><p><strong>快 95%</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>建置時間</p>
</td><td colspan="1" rowspan="1"><p>~1-3 分鐘</p>
</td><td colspan="1" rowspan="1"><p>~10-20 分鐘</p>
</td><td colspan="1" rowspan="1"><p>-</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="部署到 Cloud Run (JIT 版本)" duration="5">
        <h2 is-upgraded>1. 設定 Docker 認證</h2>
<pre><code language="language-bash" class="language-bash"># 設定環境變數
export PROJECT_ID=$(gcloud config get-value project)

# 設定 Docker 認證
gcloud auth configure-docker asia-east1-docker.pkg.dev
</code></pre>
<h2 is-upgraded>2. 標記並推送 JIT 映像檔</h2>
<pre><code language="language-bash" class="language-bash"># 標記映像檔
docker tag image-analysis-maven-jit asia-east1-docker.pkg.dev/$PROJECT_ID/jit-image-docker-repo/jit-image:v1

# 推送到 Artifact Registry
docker push asia-east1-docker.pkg.dev/$PROJECT_ID/jit-image-docker-repo/jit-image:v1
</code></pre>
<h2 is-upgraded>3. 部署到 Cloud Run</h2>
<pre><code language="language-bash" class="language-bash">gcloud run deploy my-jit-service \
  --image asia-east1-docker.pkg.dev/$PROJECT_ID/jit-image-docker-repo/jit-image:v1 \
  --region asia-east1 \
  --memory 2Gi \
  --allow-unauthenticated
</code></pre>
<p>部署完成後，進入 GCP Console 查看 <a href="https://console.cloud.google.com/run" target="_blank">Cloud Run Console</a>  服務。</p>


      </google-codelab-step>
    
      <google-codelab-step label="部署到 Cloud Run (Native 版本)" duration="25">
        <h2 is-upgraded>1. 標記並推送 Native 映像檔</h2>
<pre><code language="language-bash" class="language-bash"># 標記映像檔
docker tag image-analysis-maven-native asia-east1-docker.pkg.dev/$PROJECT_ID/native-image-docker-repo/native-image:v1

# 推送到 Artifact Registry
docker push asia-east1-docker.pkg.dev/$PROJECT_ID/native-image-docker-repo/native-image:v1
</code></pre>
<h2 is-upgraded>2. 部署到 Cloud Run</h2>
<pre><code language="language-bash" class="language-bash">gcloud run deploy my-native-service \
  --image asia-east1-docker.pkg.dev/$PROJECT_ID/native-image-docker-repo/native-image:v1 \
  --region asia-east1 \
  --memory 2Gi \
  --allow-unauthenticated
</code></pre>
<p>部署完成後，進入 GCP Console 查看 <a href="https://console.cloud.google.com/run" target="_blank">Cloud Run Console</a> 服務。</p>


      </google-codelab-step>
    
      <google-codelab-step label="設定 Eventarc 觸發器" duration="5">
        <p>Eventarc 可以讓 Cloud Storage 事件自動觸發 Cloud Run 服務。</p>
<h2 is-upgraded>1. 建立 JIT 服務的 Eventarc Trigger</h2>
<pre><code language="language-bash" class="language-bash">gcloud eventarc triggers create image-analysis-jit-trigger \
     --destination-run-service=my-jit-service \
     --destination-run-region=asia-east1 \
     --location=asia-east1 \
     --event-filters=&#34;type=google.cloud.storage.object.v1.finalized&#34; \
     --event-filters=&#34;bucket=uploaded-pictures-${PROJECT_ID}&#34; \
     --service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com
</code></pre>
<h2 is-upgraded>2. 建立 Native 服務的 Eventarc Trigger</h2>
<pre><code language="language-bash" class="language-bash">gcloud eventarc triggers create image-analysis-native-trigger \
     --destination-run-service=my-native-service \
     --destination-run-region=asia-east1 \
     --location=asia-east1 \
     --event-filters=&#34;type=google.cloud.storage.object.v1.finalized&#34; \
     --event-filters=&#34;bucket=uploaded-pictures-${PROJECT_ID}&#34; \
     --service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com
</code></pre>
<h2 is-upgraded>3. 驗證 Eventarc Trigger</h2>
<pre><code language="language-bash" class="language-bash"># 列出所有 triggers
gcloud eventarc triggers list --location=asia-east1
</code></pre>
<p class="image-container"><img alt="Eventarc Triggers" src="img/c8908d1e13a91284.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="測試事件驅動流程" duration="3">
        <h2 is-upgraded>1. 上傳圖片到 Cloud Storage</h2>
<p>準備一張測試圖片，然後上傳到 Cloud Storage (可以使用 <code>gcloud CLI</code> 或從 <code>GCP Console</code> 上傳)：</p>
<pre><code language="language-bash" class="language-bash"># 上傳圖片
gsutil cp /path/to/your/image.jpg gs://${BUCKET_PICTURES}/

# 或使用 gcloud 指令
gcloud storage cp /path/to/your/image.jpg gs://${BUCKET_PICTURES}/
</code></pre>
<h2 is-upgraded>2. 查看 Cloud Run 日誌</h2>
<p><strong>JIT Service Trigger:</strong></p>
<p class="image-container"><img alt="JIT Cloud Run Trigger" src="img/e68dfd9d82875b60.png"></p>
<p><strong>Native Service Trigger:</strong></p>
<p class="image-container"><img alt="Native Cloud Run Trigger" src="img/b47c0c0e1397eb96.png"></p>
<h2 is-upgraded>3. 驗證 Firestore 資料</h2>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/firestore" target="_blank">Firestore Console</a></li>
<li>查看 <code>pictures</code> collection</li>
<li>確認有新的文件包含圖片分析結果</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="效能監控與比較" duration="2">
        <h2 is-upgraded>查看 Cloud Run 指標</h2>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/run" target="_blank">Cloud Run Console</a></li>
<li>分別點選 <code>my-jit-service</code> 和 <code>my-native-service</code></li>
<li>查看「指標」標籤</li>
</ol>
<p class="image-container"><img alt="Cloud Run Metrics" src="img/6066de3e6306cea4.png"><img alt="Cloud Run Metrics" src="img/e6eb01118de6295d.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="清理資源" duration="5">
        <p>完成實驗後，記得清理資源以避免產生費用，也可以從 <code>GCP Console</code> 刪除！</p>
<h2 is-upgraded>1. 刪除 Eventarc Triggers</h2>
<pre><code language="language-bash" class="language-bash">gcloud eventarc triggers delete image-analysis-jit-trigger --location=asia-east1 --quiet
gcloud eventarc triggers delete image-analysis-native-trigger --location=asia-east1 --quiet
</code></pre>
<h2 is-upgraded>2. 刪除 Cloud Run 服務</h2>
<pre><code language="language-bash" class="language-bash">gcloud run services delete my-jit-service --region asia-east1 --quiet
gcloud run services delete my-native-service --region asia-east1 --quiet
</code></pre>
<h2 is-upgraded>3. 刪除 Artifact Registry Repositories</h2>
<pre><code language="language-bash" class="language-bash">gcloud artifacts repositories delete jit-image-docker-repo --location=asia-east1 --quiet
gcloud artifacts repositories delete native-image-docker-repo --location=asia-east1 --quiet
</code></pre>
<h2 is-upgraded>4. 刪除 Cloud Storage Bucket</h2>
<pre><code language="language-bash" class="language-bash"># 刪除 Bucket 及其內容
gsutil rm -r gs://${BUCKET_PICTURES}
</code></pre>
<h2 is-upgraded>5. 刪除 Firestore 資料庫</h2>
<p><strong>注意</strong>：Firestore 資料庫需要透過 Console 手動刪除</p>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/firestore" target="_blank">Firestore Console</a></li>
<li>點擊資料庫設定</li>
<li>選擇「刪除資料庫」</li>
</ol>
<h2 is-upgraded>6. 刪除 Compute Engine VM</h2>
<p>完成 Workshop 後，記得刪除 VM 以避免持續產生費用。</p>
<p><strong>透過 Console 刪除</strong>：</p>
<ol type="1">
<li>前往 <a href="https://console.cloud.google.com/compute/instances" target="_blank">Compute Engine &gt; VM 執行個體</a></li>
<li>勾選您建立的 VM（例如：<code>spring-native-workshop-vm</code>）</li>
<li>點擊上方的「刪除」按鈕</li>
<li>確認刪除</li>
</ol>
<p><strong>透過 gcloud 指令刪除</strong>：</p>
<pre><code language="language-bash" class="language-bash">gcloud compute instances delete spring-native-workshop-vm \
  --zone=asia-east1-c \
  --quiet
</code></pre>
<p><strong>提示</strong>：刪除 VM 時，預設會一併刪除開機磁碟。如果您想保留磁碟以便日後使用，請在刪除時取消勾選「刪除開機磁碟」選項。</p>


      </google-codelab-step>
    
      <google-codelab-step label="重要概念總結" duration="3">
        <h2 is-upgraded>JIT vs Native Image</h2>
<table>
<tr><td colspan="1" rowspan="1"><p>特性</p>
</td><td colspan="1" rowspan="1"><p>JIT 編譯</p>
</td><td colspan="1" rowspan="1"><p>Native Image</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>編譯時機</p>
</td><td colspan="1" rowspan="1"><p>執行時編譯</p>
</td><td colspan="1" rowspan="1"><p>建置時編譯</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>啟動速度</p>
</td><td colspan="1" rowspan="1"><p>較慢 (5-10秒)</p>
</td><td colspan="1" rowspan="1"><p>極快 (&lt;0.1秒)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>記憶體使用</p>
</td><td colspan="1" rowspan="1"><p>較高</p>
</td><td colspan="1" rowspan="1"><p>較低</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>執行效能</p>
</td><td colspan="1" rowspan="1"><p>長時間運行後最佳</p>
</td><td colspan="1" rowspan="1"><p>立即最佳</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>建置時間</p>
</td><td colspan="1" rowspan="1"><p>快 (1-5分鐘)</p>
</td><td colspan="1" rowspan="1"><p>慢 (10-20分鐘)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>映像檔大小</p>
</td><td colspan="1" rowspan="1"><p>較大 (~400MB)</p>
</td><td colspan="1" rowspan="1"><p>較小 (~200MB)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>最佳使用場景</p>
</td><td colspan="1" rowspan="1"><p>長期運行的服務</p>
</td><td colspan="1" rowspan="1"><p>Serverless/容器化應用</p>
</td></tr>
</table>
<h2 is-upgraded>何時使用 Native Image？</h2>
<p>✅ <strong>適合使用</strong>：</p>
<ul>
<li>Serverless 環境（Cloud Run, AWS Lambda）</li>
<li>需要快速啟動的應用</li>
<li>短期運行的任務</li>
<li>容器化微服務</li>
<li>資源受限環境</li>
</ul>
<p>❌ <strong>不建議使用</strong>：</p>
<ul>
<li>大量使用反射的應用</li>
<li>需要動態類別載入</li>
<li>開發階段（建置時間長）</li>
<li>需要 JVM 調優的場景</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="結論" duration="2">
        <p>恭喜完成 Spring Native Workshop！</p>
<p>在本實驗中，您已經：</p>
<ul>
<li>✅ 建置並比較了 JIT 和 Native 版本的 Spring Boot 應用程式</li>
<li>✅ 將應用程式部署到 Google Cloud Run</li>
<li>✅ 整合了多個 Google Cloud 服務（Storage, Firestore, Vision API）</li>
<li>✅ 設定了事件驅動架構（Eventarc）</li>
<li>✅ 了解了 Spring Native 的優勢和限制</li>
<li>✅ 掌握了效能監控和最佳化技巧</li>
</ul>
<h2 is-upgraded>關鍵收穫</h2>
<ol type="1">
<li><strong>Native Image 在 Serverless 環境中的優勢</strong><ul>
<li>95% 的啟動時間改善</li>
<li>50% 的記憶體節省</li>
</ul>
</li>
<li><strong>建置工具鏈</strong><ul>
<li>Maven Wrapper 確保建置一致性</li>
<li>Cloud Native Buildpacks 簡化容器化</li>
<li>GraalVM 提供原生編譯能力</li>
</ul>
</li>
<li><strong>雲端整合</strong><ul>
<li>Eventarc 建立事件驅動架構</li>
<li>Cloud Run 提供無伺服器執行環境</li>
<li>多個 GCP 服務無縫整合</li>
</ul>
</li>
</ol>
<p><strong>感謝參與本 Workshop！如有任何問題或建議，歡迎回饋。</strong></p>
<p><a href="https://seanchenr.github.io/spring-native-workshop/" target="_blank">← 返回首頁</a></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
